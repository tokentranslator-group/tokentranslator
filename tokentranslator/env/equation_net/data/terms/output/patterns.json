{"entries": [{"term": "default", "outputs": [], "dialect": "cpp", "brackets": false, "source": ["from env.equation.data.terms.output.cpp.patterns.base import Base\n", "from env.equation.data.terms.output.cpp.patterns.base import Params\n", "\n", "\n", "class Default(Base):\n", "    \n", "    '''work with mid terms\n", "    (like \"eq\", \"add\", \"sub\")\n", "    '''\n", "    \n", "    def __init__(self, net):\n", "        Base.__init__(self, net)\n", "        self.id = 'default'\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''Replace mid term with its value\n", "        from ``self.net.mid_replacers`` if term is mid.\n", "        ``replacer.set_mid_replacers`` method must be used first.\n", "        (ex mid_replacers: {\"eq\": \"=\"})'''\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "\n", "        # params = Params()\n", "\n", "        # FOR mid_replacers:\n", "        mid_replacers = self.net.mid_replacers\n", "        node_mid_name = self.net.get_node_type(node)\n", "        if node_mid_name in mid_replacers:\n", "            value = mid_replacers[node_mid_name]\n", "        else:\n", "            value = self.net.get_term_value(node)\n", "        # END FOR\n", "\n", "        self.params['value'] = value\n", "        # self.params['value'] = node.name.lex[0]\n", "        \n", "        # params['value'] = value\n", "        # self.net.set_output_data(node, self.net.get_params_field_name(),\n", "        #                          params)\n", "        \n", "    def print_out(self):\n", "    \n", "        '''For generate node out'''\n", "        self.params.has_param('value', 'Default')\n", "        return(self.params['value'])\n", "\n"]}, {"term": "bdp", "outputs": [], "dialect": "cpp", "brackets": false, "source": ["from env.equation.data.terms.output.cpp.patterns.base import Base\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.bdp')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Bdp(Base):\n", "\n", "    '''For bound like \"V(t-1.1,{x,1.3}{y, 5.3})\"'''\n", "\n", "    def __init__(self, net):\n", "        Base.__init__(self, net)\n", "        self.id = 'bdp'\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "        '''Used for fill local data'''\n", "        '''Orders and varList will be set here\n", "        from node's pattern (like {x, 2})\n", "        Return delay data\n", "        '''\n", "\n", "        delay_data = self.set_delay(node)\n", "        self.set_var_index(node)\n", "        \n", "        self.set_varList(node)\n", "        \n", "        # add delays data for postproc:\n", "        if delay_data is not None:\n", "            self.net.set_output_data(node, 'delay_data', delay_data)\n", "\n", "    def set_node_data(self, **kwargs):\n", "\n", "        '''For setting data before replacment'''\n", "        '''Set shape,\n", "        vars_to_indexes'''\n", "        \n", "        self.set_shape(**kwargs)\n", "        self.set_vars_indexes(**kwargs)\n", "        self.set_blockNumber(**kwargs)\n", "        self.set_dim(**kwargs)\n", "\n", "    def set_shape(self, **kwargs):\n", "        '''\n", "        shape=[3, 3]\n", "        '''\n", "        try:\n", "            self.params['shape'] = kwargs['shape']\n", "        except:\n", "            logger.info(\"kwargs['shape'] fail\")\n", "\n", "    def print_out(self):\n", "\n", "        '''For generate node out'''\n", "\n", "        return(self.var_point())\n", "\n", "    def var_point(self):\n", "        '''\n", "        DESCRIPTION:\n", "        For patterns like\n", "        U(t,{x,0.7})\n", "        U(t,{x,0.7}{y,0.3})\n", "        '''\n", "        self.params.has_param('dim', 'Bdp')\n", "        self.params.has_param('indepVarList', 'Bdp')\n", "        self.params.has_param('shape', 'Bdp')\n", "\n", "        self.params.has_param('blockNumber', 'Bdp')\n", "        self.params.has_param('unknownVarIndex', 'Bdp')\n", "\n", "        if self.params['dim'] == 1:\n", "\n", "            print(self.params['indepVarList'])\n", "            val_x = self.params['indepVarOrders']['x']\n", "            x = str(int(float(val_x)*self.params['shape'][0]))\n", "\n", "            return(self.var_point_1d(x))\n", "        elif self.params['dim'] == 2:\n", "\n", "            self.params.has_param('indepVarOrders', 'Bdp')\n", "            val_x = self.params['indepVarOrders']['x']\n", "            val_y = self.params['indepVarOrders']['y']\n", "            \n", "            x = str(int(float(val_x)*self.params['shape'][0]))\n", "            y = str(int(float(val_y)*self.params['shape'][1]))\n", "\n", "            return(self.var_point_2d(x, y))\n", "\n", "    def var_point_1d(self, x):\n", "        '''\n", "        DESCRIPTION:\n", "        For patterns like U(t,{x,0.7})\n", "        '''\n", "        blockNumber = self.params['blockNumber']\n", "        varIndex = self.params['unknownVarIndex']\n", "        '''\n", "        return('source[delay]['+str(x)+'*idxX'+'*'\n", "               + 'Block'+str(blockNumber)+'CELLSIZE+'\n", "               + str(varIndex)+']')\n", "        '''\n", "        return('source[delay]['+str(x)+''+'*'\n", "               + 'Block'+str(blockNumber)+'CELLSIZE+'\n", "               + str(varIndex)+']')\n", "\n", "    def var_point_2d(self, x, y):\n", "        '''\n", "        DESCRIPTION:\n", "        For U(t,{x,0.7}{y,0.3})\n", "        '''\n", "        blockNumber = self.params['blockNumber']\n", "        varIndex = self.params['unknownVarIndex']\n", "        '''\n", "        return(('source[delay][('+str(x)+'*idxX'\n", "                + '+'\n", "                + str(y)+'*idxY*Block'\n", "                + str(blockNumber)\n", "                + 'StrideY)*'\n", "                + 'Block'+str(blockNumber)+'CELLSIZE+'\n", "                + str(varIndex)+']'))\n", "        '''\n", "        return(('source[delay][('+str(x)+''\n", "                + '+'\n", "                + str(y)+'*Block'\n", "                + str(blockNumber)\n", "                + 'StrideY)*'\n", "                + 'Block'+str(blockNumber)+'CELLSIZE+'\n", "                + str(varIndex)+']'))\n", "\n", "\n"]}, {"term": "diff_time_var", "outputs": [], "dialect": "cpp", "brackets": false, "source": ["from env.equation.data.terms.output.cpp.patterns.var import Var\n", "\n", "\n", "class DiffTimeVar(Var):\n", "\n", "    '''For term like U', V'. \n", "    They differ from Var only in lex'''\n", "\n", "    def __init__(self, net):\n", "        Var.__init__(self, net)\n", "        self.id = 'diff_time'\n", "\n", "\n", "\n"]}, {"term": "diff", "outputs": [], "dialect": "cpp", "brackets": false, "source": ["import os\n", "import sys\n", "import inspect\n", "# insert env dir into sys\n", "# env must contain env folder:\n", "currentdir = os.path.dirname(os.path\n", "                             .abspath(inspect.getfile(inspect.currentframe())))\n", "env = currentdir.find(\"env\")\n", "env_dir = currentdir[:env]\n", "# print(env_dir)\n", "if env_dir not in sys.path:\n", "    sys.path.insert(0, env_dir)\n", "\n", "from env.equation.data.terms.output.cpp \\\n", "    .additions.deriv.gen_pure_common import GenPureCommon\n", "\n", "from env.equation.data.terms.output.cpp \\\n", "    .additions.deriv.gen_pure_borders import GenPureBorders\n", "\n", "from env.equation.data.terms.output.cpp \\\n", "    .additions.deriv.gen_pure_ics import GenPureIcs\n", "\n", "from env.equation.data.terms.output.cpp \\\n", "    .additions.deriv.gen_pure_vertexs import GenPureVertexs\n", "\n", "from env.equation.data.terms.output.cpp.patterns.base import Base\n", "# from env.equation.data.terms.output.cpp.additions.deriv import PureDerivGenerator\n", "from env.equation.data.terms.output.cpp.additions.deriv_old import MixDerivGenerator\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "# logger = logging.getLogger('replacer_cpp.diff')\n", "\n", "# if using directly uncoment that:\n", "\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('diff.py')\n", "logger.setLevel(level=log_level)\n", "\n", "\n", "class Diff(Base):\n", "\n", "    '''Generate cpp data for diff:\n", "    D[U(t-1.1), {x, 3}]'''\n", "\n", "    def __init__(self, net):\n", "\n", "        Base.__init__(self, net)\n", "        self.id = 'diff'\n", "\n", "    def set_node_data(self, **kwargs):\n", "\n", "        '''For setting data before replacment'''\n", "        \n", "        self.set_diff_type(**kwargs)\n", "        self.set_vars_indexes(**kwargs)\n", "        self.set_blockNumber(**kwargs)\n", "\n", "    def set_diff_type(self, **kwargs):\n", "        '''\n", "        Inputs:\n", "           diffType=\"pure\", diffMethod=\"common\"\n", "\n", "           diffType=\"pure\", diffMethod=\"borders\",\n", "           side=0, func=\"sin(x)\"\n", "\n", "           diffType=\"pure\", diffMethod=\"interconnect\",\n", "           side=0, firstIndex=0, secondIndexSTR=1\n", "        '''\n", "\n", "        try:\n", "            self.params['diffType'] = kwargs['diffType']\n", "            self.params['diffMethod'] = kwargs['diffMethod']\n", "        except:\n", "            raise(BaseException(\"for diff term diffType and diffMethod\"\n", "                                + \"(see Diff._set_diff_type for more)\"\n", "                                + \" params needed\"))\n", "\n", "        diffMethod = self.params['diffMethod']\n", "        if diffMethod == 'borders':\n", "            try:\n", "                self.params['side'] = kwargs['side']\n", "                self.params['func'] = kwargs['func']\n", "            except:\n", "                raise(BaseException(('for method borders side'\n", "                                     + ' and func must be given'\n", "                                     + \"(see Diff._set_diff_type for more)\")))\n", "        elif diffMethod == 'interconnect':\n", "            try:\n", "                self.params['side'] = kwargs['side']\n", "                self.params['firstIndex'] = kwargs['firstIndex']\n", "                self.params['secondIndexSTR'] = kwargs['secondIndexSTR']\n", "            except:\n", "                raise(BaseException(('for method interconnect'\n", "                                     + ' side, firstIndex and secondIndexSTR'\n", "                                     + ' must be given'\n", "                                     + \"(see Diff._set_diff_type for more)\")))\n", "        elif diffMethod == 'vertex':\n", "            try:\n", "                self.params['vertex_sides'] = kwargs['vertex_sides']\n", "                self.params['func'] = kwargs['func']\n", "            except:\n", "                raise(BaseException(('for method vertex vertex_sides'\n", "                                     + \"(see Diff._set_diff_type for more)\"\n", "                                     + 'must be given')))\n", "    \n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "        '''Used for dinamicaly fill local data'''\n", "        '''Orders and varList will be set here\n", "        from node's pattern (like {x, 2})\n", "        Return delay data.\n", "        '''\n", "\n", "        self.set_varList(node)\n", "        self.set_var_index(node)\n", "        delay_data = self.set_delay(node)\n", "\n", "        # add delays data for postproc:\n", "        if delay_data is not None:\n", "            # node.output.cpp.global_data = data\n", "            self.net.set_output_data(node, 'delay_data', delay_data)\n", "\n", "        '''\n", "        if delay_data is not None:\n", "            return({'delay_data': delay_data})\n", "        else:\n", "            return(None)\n", "        '''\n", "\n", "    def print_out(self):\n", "        \n", "        '''For generate node out'''\n", "        '''\n", "        global_params = {\n", "            # int: shift index for variable like\n", "            # like (U,V)-> (source[+0], source[+1])\n", "            'unknownVarIndex': 0\n", "                \n", "            'blockNumber': 0\n", "            'side': 0\n", "\n", "            'diffType': 'pure'\n", "            'diffMethod': 'vertex'}\n", "        '''\n", "        # check params avelable:\n", "        self.params.has_param('blockNumber', 'Diff')\n", "        self.params.has_param('unknownVarIndex', 'Diff')\n", "        self.params.has_param('indepVarList', 'Diff')\n", "        self.params.has_param('diffMethod', 'Diff')\n", "        self.params.has_param('indepVarOrders', 'Diff')\n", "        return(self.diff())\n", "\n", "    def diff(self):\n", "        '''\n", "        DESCRIPTION:\n", "        self.params should be initiated first.\n", "        '''\n", "        logger.debug(\"FROM diff:\")\n", "        if (self.params['diffMethod'] is None\n", "            or self.params['diffType'] is None):\n", "            raise(BaseException('set_diff_type first'))\n", "        if self.params['diffType'] == 'pure':\n", "            if self.params['diffMethod'] == 'common':\n", "                return(self.diff_pure_common())\n", "            if self.params['diffMethod'] == 'borders':\n", "                return(self.diff_pure_borders())\n", "            if self.params['diffMethod'] == 'interconnect':\n", "                return(self.diff_pure_ics())\n", "            if self.params['diffMethod'] == 'vertex':\n", "                return(self.diff_pure_vertex())\n", "\n", "    def diff_pure_common(self):\n", "        # for debug\n", "        logger.debug(\"diffType: pure, common\")\n", "\n", "        blockNumber = self.params[\"blockNumber\"]\n", "        unknownVarIndex = self.params[\"unknownVarIndex\"]\n", "        indepVar = self.params[\"indepVarList\"][0]\n", "        indepVarOrders = self.params[\"indepVarOrders\"]\n", "        logger.debug(\"indepVarOrders:\")\n", "        logger.debug(indepVarOrders)\n", "        gen = GenPureCommon(blockNumber, unknownVarIndex,\n", "                            indepVar, indepVarOrders)\n", "        out = gen.common_diff()\n", "\n", "        return(out)\n", "\n", "    def diff_pure_borders(self):\n", "        # for debug\n", "        logger.debug(\"diffType: pure, spec\")\n", "\n", "        blockNumber = self.params[\"blockNumber\"]\n", "        unknownVarIndex = self.params[\"unknownVarIndex\"]\n", "        indepVar = self.params[\"indepVarList\"][0]\n", "        indepVarOrders = self.params[\"indepVarOrders\"]\n", "\n", "        side = self.params['side']\n", "        border_func = self.params['func']\n", "    \n", "        gen = GenPureBorders(blockNumber, unknownVarIndex,\n", "                             indepVar, indepVarOrders)\n", "        gen.set_special_params(side)\n", "        out = gen.borders_diff(border_func)\n", "\n", "        logger.debug(\"\\ndiff_pure_borders out:\")\n", "        logger.debug(out)\n", "        logger.debug(\"\\nparams:\")\n", "        logger.debug(self.params)\n", "\n", "        return(out)\n", "\n", "    def diff_pure_ics(self):\n", "\n", "        # for debug\n", "        logger.debug(\"diffType: pure, interconnect\")\n", "\n", "        blockNumber = self.params[\"blockNumber\"]\n", "        unknownVarIndex = self.params[\"unknownVarIndex\"]\n", "        indepVar = self.params[\"indepVarList\"][0]\n", "        indepVarOrders = self.params[\"indepVarOrders\"]\n", "\n", "        side = self.params['side']\n", "        firstIndex = self.params['firstIndex']\n", "        secondIndexSTR = self.params['secondIndexSTR']\n", "\n", "        gen = GenPureIcs(blockNumber, unknownVarIndex,\n", "                         indepVar, indepVarOrders)\n", "        gen.set_special_params(side, firstIndex, secondIndexSTR)\n", "        out = gen.ics_diff()\n", "        return(out)\n", "\n", "    def diff_pure_vertex(self):\n", "\n", "        # for debug\n", "        logger.debug(\"diffType: pure, vertexs\")\n", "\n", "        blockNumber = self.params[\"blockNumber\"]\n", "        unknownVarIndex = self.params[\"unknownVarIndex\"]\n", "        indepVar = self.params[\"indepVarList\"][0]\n", "        indepVarOrders = self.params[\"indepVarOrders\"]\n", "\n", "        border_func = self.params['func']\n", "        vertex_sides = self.params['vertex_sides']\n", "\n", "        gen = GenPureVertexs(blockNumber, unknownVarIndex,\n", "                             indepVar, indepVarOrders)\n", "        gen.set_special_params(vertex_sides)\n", "\n", "        out = gen.vertexs_diff(border_func)\n", "\n", "        logger.debug(\"\\ndiff_pure_vertex out:\")\n", "        logger.debug(out)\n", "        logger.debug(\"\\nparams:\")\n", "        logger.debug(self.params)\n", "\n", "        return(out)\n", "\n", "    def diff_mix_common(self):\n", "        # for debug\n", "        logger.debug(\"diffType: pure, common\")\n", "        diffGen = MixDerivGenerator(self.params)\n", "        out = diffGen.common_diff()\n", "        return(out)\n", "\n", "    def diff_mix_spec(self):\n", "        # for debug\n", "        logger.debug(\"diffType: pure, spec\")\n", "        diffGen = MixDerivGenerator(self.params)\n", "        func = self.params['func']\n", "        out = diffGen.special_diff(func)\n", "        return(out)\n", "\n", "    def diff_mix_ics(self):\n", "        # for debug\n", "        logger.debug(\"diffType: pure, interconnect\")\n", "        diffGen = MixDerivGenerator(self.params)\n", "        out = diffGen.interconnect_diff()\n", "        return(out)\n", "\n", "    def diff_none(self):\n", "        # for debug\n", "        logger.debug(\"diffMethod: None\")\n", "        raise(BaseException(\"\\ndiff_none is depricated\"\n", "                            + \"\\nset diffMethod first\"))\n", "\n", "\n", "\n", "\n"]}, {"term": "free_var", "outputs": [], "dialect": "cpp", "brackets": false, "source": ["from env.equation.data.terms.output.cpp.patterns.base import Base\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.free_var')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class FreeVar(Base):\n", "\n", "    '''x->idxX, y->idxY, z->idxZ '''\n", "\n", "    def __init__(self, net):\n", "        Base.__init__(self, net)\n", "        self.id = 'free_var'\n", "        \n", "        # setup prefix for var\n", "        def prefix(val, state):\n", "          \n", "          '''x |-> Block0OffsetX+idxX*DX'''\n", "          \n", "          cval = val.upper()\n", "          blockNumber = str(state.params['blockNumber'])\n", "          return(\"(\"+\"Block\"+blockNumber+\"Offset\"\n", "                 +cval+\"+idx\"+cval+\"*D\"+cval+\")\")\n", "        self.params[\"free_var_prefix\"] = prefix\n", "        # self.params[\"free_var_prefix\"] = lambda val, state: \"idx\"+val.upper()\n", "\n", "    def set_free_var_prefix(self, **kwargs):\n", "        \n", "        ''' x |-> params[\"free_var_prefix\"](x, self)\n", "\n", "        Input:\n", "        free_var_prefix = lambda val, state: \"idx\"+val.upper()\n", "        '''\n", "    \n", "        try:\n", "            prefix = kwargs['free_var_prefix']\n", "            self.params['free_var_prefix'] = prefix\n", "        except KeyError:\n", "            logger.info(\"kwargs['free_var_prefix'] fail\")\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "        '''Used for fill local data.\n", "        Extract var_name'''\n", "\n", "        self.params['var_name'] = self.net.get_term_value(node)\n", "        # self.params['var_name'] = node.name.lex[0]\n", "\n", "    def set_node_data(self, **kwargs):\n", "\n", "        '''For setting data before replacment'''\n", "        pass\n", "\n", "    def print_out(self):\n", "\n", "        '''x->idxX, y->idxY, z->idxZ '''\n", "\n", "        self.params.has_param('var_name', 'FreeVar')\n", "        var_name = self.params['var_name']\n", "        return(self.params[\"free_var_prefix\"](var_name, self))\n", "        # return(\"idx\"+var_name.upper())\n", "\n", "\n", "\n", "\n", "\n"]}, {"term": "coeffs", "outputs": [], "dialect": "cpp", "brackets": false, "source": ["from env.equation.data.terms.output.cpp.patterns.base import Base\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.coeffs')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Coeffs(Base):\n", "    \n", "    '''map  coeffs ot it's index\n", "    like (a,b)-> (params[+0], params[+1])\n", "    '''\n", "    \n", "    def __init__(self, net):\n", "        Base.__init__(self, net)\n", "        self.id = 'coeffs'\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "        '''Used for fill local data'''\n", "\n", "        self.set_coeff_index(node)\n", "\n", "    def set_coeff_index(self, node):\n", "        \n", "        coeffs = self.net.get_term_value(node)\n", "        # coeffs = node.name.lex[0]\n", "\n", "        self.params.has_param('map_cti', 'Coeffs')\n", "\n", "        self.params['coeffsIndex'] = self.params['map_cti'][coeffs]\n", "        \n", "    def set_node_data(self, **kwargs):\n", "\n", "        '''For setting data before replacment'''\n", "\n", "        self._set_coeffs_indexes(**kwargs)\n", "\n", "    def set_coeffs_indexes(self, **kwargs):\n", "\n", "        '''\n", "        Input:\n", "        coeffs_to_indexes=[('a', 0), ('b', 1)]\n", "        '''\n", "        try:\n", "            # map  coeffs ot it's index\n", "            # like (a,b)-> (params[+0], params[+1])\n", "            map_cti = dict(kwargs['coeffs_to_indexes'])\n", "            self.params['map_cti'] = map_cti\n", "        except:\n", "            logger.info(\"kwargs['coeffs_to_indexes'] fail\")\n", "\n", "    def print_out(self):\n", "        \n", "        '''For generate node out'''\n", "\n", "        self.params.has_param('coeffsIndex', 'Coeffs')\n", "\n", "        coeffsIndex = self.params['coeffsIndex']\n", "        \n", "        return('params['\n", "               + str(coeffsIndex)\n", "               + ']')\n", "\n", "\n"]}, {"term": "var", "outputs": [], "dialect": "cpp", "brackets": false, "source": ["from env.equation.data.terms.output.cpp.patterns.base import Base\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.var')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Var(Base):\n", "\n", "    '''For U, V, U(t-1.1)'''\n", "\n", "    def __init__(self, net):\n", "        Base.__init__(self, net)\n", "        self.id = 'var'\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "        '''Used for fill local data'''\n", "        '''Orders and varList will be set here\n", "        from node's pattern (like {x, 2})\n", "        Return delay data\n", "        '''\n", "\n", "        delay_data = self.set_delay(node)\n", "\n", "        # add delays data for postproc:\n", "        if delay_data is not None:\n", "            # node.output.cpp.global_data = data\n", "            self.net.set_output_data(node, 'delay_data', delay_data)\n", "\n", "        self.set_var_index(node)\n", "\n", "    def set_node_data(self, **kwargs):\n", "\n", "        '''For setting data before replacment'''\n", "        '''int: shift index for variable like\n", "        like (U,V)-> (source[+0], source[+1])\n", "        '''\n", "        '''\n", "        Input:\n", "        vars_to_indexes=[('U', 0), ('V', 1)]\n", "        '''\n", "                \n", "        self.set_vars_indexes(**kwargs)\n", "\n", "    def print_out(self):\n", "        \n", "        '''For generate node out'''\n", "\n", "        self.params.has_param('unknownVarIndex', 'Var')\n", "\n", "        return(self.var_simple())\n", "\n", "    def var_simple(self):\n", "        '''\n", "        DESCRIPTION:\n", "        varIndex usage:\n", "        source[][idx+0] - x\n", "        source[][idx+1] - y\n", "        source[][idx+2] - z\n", "        \n", "        '''\n", "\n", "        varIndex = self.params['unknownVarIndex']\n", "        return('source['\n", "               + 'delay'\n", "               + '][idx + '\n", "               + str(varIndex)\n", "               + ']')\n", "\n", "    def var_1d(self):\n", "        # TODO\n", "        self.params.has_param('blockNumber', 'Var')\n", "\n", "        blockNumber = self.params.blockNumber\n", "        varIndex = self.params.unknownVarIndex\n", "        return('source[delay][idx'+'+'+'idxX'+'*'\n", "               + 'Block'+str(blockNumber)+'CELLSIZE'\n", "               + '+'+str(varIndex)+']')\n", "        \n", "    def var_2d(self):\n", "        # TODO\n", "        self.params.has_param('blockNumber', 'Var')\n", "\n", "        blockNumber = self.params.blockNumber\n", "        varIndex = self.params.unknownVarIndex\n", "        return(('source[delay][(idx'\n", "                + '+'\n", "                + 'idxX'+'*Block'\n", "                + str(blockNumber)\n", "                + 'StrideY)*'\n", "                + 'Block'+str(blockNumber)+'CELLSIZE'\n", "                + '+'+str(varIndex) + ']'))\n", "\n"]}, {"term": "float", "outputs": [], "dialect": "cpp", "brackets": false, "source": ["from env.equation.data.terms.output.cpp.patterns.base import Base\n", "\n", "import logging\n", "\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.float')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Float(Base):\n", "    \n", "    '''1.1\n", "    '''\n", "    \n", "    def __init__(self, net):\n", "        Base.__init__(self, net)\n", "        self.id = 'float'\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "\n", "        self.value = self.net.get_term_value(node)\n", "        # self.value = node.name.lex[0]\n", "\n", "    def print_out(self):\n", "    \n", "        '''For generate node out'''\n", "\n", "        return(self.value)\n", "\n"]}, {"term": "func", "outputs": [], "dialect": "cpp", "brackets": true, "source": ["import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.func')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "# test 1\n", "class Func():\n", "    \n", "    '''for f (left=f right=))'''\n", "    \n", "    def __init__(self, net):\n", "        self.net = net\n", "        self.gnet = self.net.net\n", "\n", "        # this mean left_term.name == 'f'\n", "        # right_node.name == ')'\n", "        self.id = 'l:f|r:)'\n", "\n", "    def __call__(self, node_br):\n", "        \n", "        '''Add cpp out to brackets'''\n", "\n", "        successors = self.gnet.get_successors(node_br)\n", "        \n", "        left_node = successors[0]\n", "        right_node = successors[-1]\n", "\n", "        args_node = successors[1]\n", "\n", "        # get node data:\n", "        self.get_node_data(left_node, right_node)\n", "        \n", "        # transform to cpp:\n", "        left_out, right_out = self.print_out()\n", "\n", "        self.gnet.set_output_out(left_node, left_out)\n", "        self.gnet.set_output_out(right_node, right_out)\n", "\n", "    def get_node_data(self, left_node, right_node):\n", "\n", "        '''Used for fill local data'''\n", "\n", "        self.func_name = self.gnet.get_term_value(left_node)\n", "        \n", "    def print_out(self):\n", "        \n", "        left = self.func_name\n", "        right = \")\"\n", "        return(left, right)\n", "\n", "\n", "\n"]}, {"term": "pow", "outputs": [], "dialect": "cpp", "brackets": true, "source": ["import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.pow')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "# test\n", "class Pow():\n", "    \n", "    '''for pow (left=( right=w)'''\n", "    \n", "    def __init__(self, net):\n", "        self.net = net\n", "        self.gnet = self.net.net\n", "        # this mean rigth_term.name == 'w'\n", "        # left_term.name == '('\n", "        self.id = 'l:(|r:w'\n", "\n", "    def __call__(self, node_br):\n", "\n", "        '''Add cpp out to brackets'''\n", "\n", "        successors = self.gnet.get_successors(node_br)\n", "        \n", "        left_node = successors[0]\n", "        right_node = successors[-1]\n", "\n", "        args_node = successors[1]\n", "        \n", "        # get term data:\n", "        self.get_node_data(left_node, right_node)\n", "        \n", "        # transform to cpp:\n", "        left_out, right_out = self.print_out()\n", "\n", "        self.gnet.set_output_out(left_node, left_out)\n", "        self.gnet.set_output_out(right_node, right_out)\n", "\n", "    def get_node_data(self, left_node, right_node):\n", "\n", "        '''Used for fill local data'''\n", "\n", "        self.set_pow_degree(right_node)\n", "\n", "    def set_pow_degree(self, node):\n", "        # try:\n", "        # if name is a Word\n", "        right = self.gnet.get_term_value(node)\n", "        # except AttributeError:\n", "        #     # if name is a str\n", "        #     right = term.name\n", "\n", "        self.degree = right.split('^')[1]\n", "        \n", "    def print_out(self):\n", "        \n", "        degree = str(self.degree)\n", "        left = \"pow(\"\n", "        right = \",\" + degree + \")\"\n", "        return(left, right)\n", "\n", "\n"]}, {"term": "base", "brackets": false, "dialect": "cpp", "outputs": [], "source": ["import abc\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.base')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Params(dict):\n", "    '''\n", "    def __init__(self):\n", "        self.diffType = None  # 'pure'\n", "        self.diffMethod = None  # 'vertex'\n", "\n", "        # int: shift index for variable like\n", "        # like (U,V)-> (source[+0], source[+1])\n", "        self.unknownVarIndexes = []\n", "\n", "        # {x, 2}\n", "        self.indepVarList = []\n", "        self.indepVarOrders = {}\n", "        self.derivOrder = None\n", "\n", "        self.blockNumber = None\n", "        self.side = None\n", "    '''\n", "\n", "    def has_param(self, key, source):\n", "        try:\n", "            self[key]\n", "        except KeyError:\n", "            raise(KeyError('for term %s dont have %s param' % (source, key)))\n", "            \n", "\n", "class Base():\n", "    metaclass = abc.ABCMeta\n", "\n", "    '''Common methods for all cpp terms'''\n", "\n", "    def __init__(self, net):\n", "\n", "        self.net = net\n", "        self.params = Params()\n", "\n", "    def __call__(self, node):\n", "\n", "        '''Extract data from node lex pattern add it\n", "        to node.cpp.global_data and generate out to it\n", "        node.output.cpp.out'''\n", "\n", "        self.get_node_data(node)\n", "        \n", "        # transform to cpp:\n", "        out = self.print_out()\n", "        self.net.set_output_out(node, out)\n", "        # node.output.cpp.out = self.print_out()\n", "\n", "    @abc.abstractmethod\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "\n", "        raise(BaseException(('get_node_data method of BaseTerm class'\n", "                             + ' must be implemented')))\n", "    \n", "    @abc.abstractmethod\n", "    def set_node_data(self, **kwargs):\n", "\n", "        '''For setting data before replacment'''\n", "\n", "        raise(BaseException(('set_node_data method of BaseTerm class'\n", "                             + ' must be implemented')))\n", "\n", "    @abc.abstractmethod\n", "    def print_out(self):\n", "\n", "        '''For generate node out'''\n", "\n", "        raise(BaseException(('print_out method of BaseTerm class'\n", "                             + ' must be implemented')))\n", "\n", "    def set_dim(self, **kwargs):\n", "        try:\n", "            dim = kwargs['dim']\n", "            self.params['dim'] = dim\n", "        except KeyError:\n", "            logger.info(\"kwargs['dim'] fail\")\n", "\n", "    def set_blockNumber(self, **kwargs):\n", "        try:\n", "            blockNumber = kwargs['blockNumber']\n", "            self.params['blockNumber'] = blockNumber\n", "        except KeyError:\n", "            logger.info(\"kwargs['blockNumber'] fail\")\n", "\n", "    def set_var_index(self, node):\n", "        var = self.net.get_term_pattern(node).group('val')\n", "        # var = node.name.lex[1].group('val')\n", "\n", "        # for case like U(t-1.1)\n", "        var = var[0]\n", "        self.params['unknownVarIndex'] = self.params['map_vti'][var]\n", "\n", "    def set_vars_indexes(self, **kwargs):\n", "        '''Input:\n", "\n", "        - ``unknownVarIndex`` -- shift index for variable\n", "        (like (U, V)-> (source[+0], source[+1]))\n", "        (Ex: [('U', 0), ('V', 1)])\n", "        '''\n", "\n", "        try:\n", "            map_vti = dict(kwargs['vars_to_indexes'])\n", "            self.params['map_vti'] = map_vti\n", "        except KeyError:\n", "            logger.info(\"kwargs['vars_to_indexes'] fail\")\n", "\n", "    def set_delay(self, node):\n", "\n", "        '''Find values and it's delay (like (t-1.1))\n", "        and add node index to global_params\n", "        (for conversion in postprocessing)'''\n", "\n", "        pattern = self.net.get_term_pattern(node)\n", "        # pattern = node.name.lex[1]\n", "        # print(pattern.groups())\n", "        delay = pattern.group('delay')\n", "        if delay is not None:\n", "            self.net.global_params.delays_owner_id += 1\n", "            delay_index = self.net.global_params.delays_owner_id\n", "            self.net.global_params.delays[delay_index] = delay\n", "\n", "            # var_index ex: U(t-1.1)\n", "            var_index = pattern.group('val')\n", "            return((delay_index, var_index, delay))\n", "            \n", "        return(None)\n", "\n", "    def set_varList(self, node):\n", "\n", "        '''Find values and it's orders (like {x, 2})\n", "        Or {x, 2.1} for case of bdp'''\n", "        \n", "        pattern = self.net.get_term_pattern(node)\n", "        # pattern = node.name.lex[1]\n", "\n", "        logger.debug(\"pattern.string:\")\n", "        logger.debug(pattern.string)\n", "        logger.debug(\"pattern.groupdict():\")\n", "        logger.debug(pattern.groupdict())\n", "\n", "        for var in 'xyz':\n", "            order = pattern.group('val_'+var)\n", "            if order is not None:\n", "                self.params['indepVarList'] = [var]\n", "                '''\n", "                if 'indepVarList' in self.params:\n", "                    self.params['indepVarList'].append(var)\n", "                else:\n", "                    self.params['indepVarList'] = [var]\n", "                '''\n", "                # do not refill orders if they alredy exist:\n", "                if 'indepVarOrders' in self.params:\n", "                    self.params['indepVarOrders'][var] = float(order)\n", "                else:\n", "                    self.params['indepVarOrders'] = dict([(var, float(order))])\n", "                # break\n", "\n", "    def print_dbg(self, *args):\n", "        if self.dbg:\n", "            for arg in args:\n", "                print(self.dbgInx*' '+str(arg))\n", "            print('')\n", "\n"]}, {"term": "brackets_main", "brackets": true, "dialect": "cpp", "outputs": [], "source": ["from translator.replacer.replacer_brackets import GenBrackets\n", "\n", "from env.equation.data.terms.output.cpp.patterns.brackets.func import Func\n", "from env.equation.data.terms.output.cpp.patterns.brackets.pow import Pow\n", "\n", "\n", "import logging\n", "\n", "\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.brackets_main')\n", "\n", "# if using directly uncoment that:\n", "\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('cpp_net')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "terms_br_gens = [Func, Pow]\n", "\n", "\n", "class Out():\n", "    pass\n", "\n", "\n", "class BracketsNet(GenBrackets):\n", "    \n", "    '''Class for all brackets terms.\n", "    Terms for brackets replacement will be\n", "    in self[]'''\n", "\n", "    def get_terms_gen_cls(self):\n", "        # self.net.patterns_editor\n", "        return(terms_br_gens)\n", "\n"]}, {"term": "diff_time_var", "brackets": false, "dialect": "sympy", "outputs": [], "source": ["from env.equation.data.terms.output.sympy.patterns.base import Base\n", "from env.equation.data.terms.output.sympy.patterns.base import Params\n", "from env.equation.data.terms.common.sympy.base import CommonSympy\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_sympy.diff_time')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class DiffTimeVar(Base, CommonSympy):\n", "\n", "    '''Generate cpp data for diff:\n", "    D[U(t-1.1), {x, 3}] -> sympy.diff(U(t-1.1, x), x, 3)'''\n", "\n", "    def __init__(self, net):\n", "\n", "        Base.__init__(self, net)\n", "        self.id = 'diff_time'\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "        '''Used for dinamicaly fill local data'''\n", "        '''Orders and varList will be set here\n", "        from node's pattern (like {x, 2})\n", "        Return delay data.\n", "        '''\n", "        params = Params()\n", "\n", "        reg_pattern = self.net.get_term_pattern(node)\n", "\n", "        # diff var (U):\n", "        var = reg_pattern.group('val')\n", "\n", "        # add args x, y to var:\n", "        var = self.add_args(var, reg_pattern)\n", "\n", "        # transform to sympy:\n", "        out = \"sympy.diff(%s, t)\" % (var)\n", "\n", "        params['out'] = out\n", "        self.params['out'] = out\n", "\n", "        self.net.set_output_data(node, self.net.get_params_field_name(),\n", "                                 params)\n", "        \n", "    def print_out(self):\n", "        \n", "        '''For generate node out'''\n", "        \n", "        return(self.params['out'])\n", "\n", "\n"]}, {"term": "diff", "brackets": false, "dialect": "sympy", "outputs": [], "source": ["from env.equation.data.terms.output.sympy.patterns.base import Base\n", "from env.equation.data.terms.output.sympy.patterns.base import Params\n", "from env.equation.data.terms.common.sympy.base import CommonSympy\n", "from env.equation.data.terms.common.sympy.diff import DiffSympy\n", "\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_sympy.diff')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Diff(Base, CommonSympy, DiffSympy):\n", "\n", "    '''Generate cpp data for diff:\n", "    D[U(t-1.1), {x, 3}] -> sympy.diff(U(t-1.1, x), x, 3)'''\n", "\n", "    def __init__(self, net):\n", "\n", "        Base.__init__(self, net)\n", "        self.id = 'diff'\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "        '''Used for dinamicaly fill local data'''\n", "        '''Orders and varList will be set here\n", "        from node's pattern (like {x, 2})\n", "        '''\n", "\n", "        params = Params()\n", "\n", "        reg_pattern = self.net.get_term_pattern(node)\n", "\n", "        # diff var (U):\n", "        var = reg_pattern.group('val')\n", "\n", "        '''\n", "        # find diff orders (free_var: x, order: 1):\n", "        for free_var in 'xyz':\n", "            order = reg_pattern.group('val_'+free_var)\n", "            if order is not None:\n", "                break\n", "        '''\n", "        \n", "        # add args x, y to var:\n", "        params['var'] = self.add_args(var, reg_pattern)\n", "\n", "        free_vars = self.get_free_vars(reg_pattern)\n", "        params['free_vars'] = free_vars\n", "        \n", "        out = self.make_diff_pattern(var, free_vars)\n", "        '''\n", "        out = \"sympy.diff(%s,\" % (var)\n", "        for free_var in free_vars:\n", "            order = free_vars[free_var]\n", "            out += \"%s, %s\" % (free_var, order)\n", "        out += \")\"\n", "        '''\n", "        # out = \"sympy.diff(%s, %s, %s)\" % (var, free_var, order)\n", "        \n", "        params['out'] = out\n", "        self.params['out'] = out\n", "\n", "        self.net.set_output_data(node, self.net.get_params_field_name(),\n", "                                 params)\n", "        \n", "    def print_out(self):\n", "        \n", "        '''For generate node out'''\n", "        \n", "        return(self.params['out'])\n", "\n", "\n"]}, {"term": "default", "brackets": false, "dialect": "sympy", "outputs": [], "source": ["from env.equation.data.terms.output.sympy.patterns.base import Base\n", "from env.equation.data.terms.output.sympy.patterns.base import Params\n", "\n", "import logging\n", "\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_sympy.default')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Default(Base):\n", "    \n", "    '''node.name.lex[0]\n", "    '''\n", "    \n", "    def __init__(self, net):\n", "        Base.__init__(self, net)\n", "        self.id = 'default'\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "\n", "        # params = Params()\n", "\n", "        # FOR mid_replacers:\n", "        mid_replacers = self.net.mid_replacers\n", "        node_mid_name = self.net.get_node_type(node)\n", "        if node_mid_name in mid_replacers:\n", "            value = mid_replacers[node_mid_name]\n", "        else:\n", "            value = self.net.get_term_value(node)\n", "        # END FOR\n", "\n", "        self.params['value'] = value\n", "        # self.params['value'] = node.name.lex[0]\n", "        \n", "        # params['value'] = value\n", "        # self.net.set_output_data(node, self.net.get_params_field_name(),\n", "        #                          params)\n", "        \n", "    def print_out(self):\n", "    \n", "        '''For generate node out'''\n", "        self.params.has_param('value', 'Default')\n", "        return(self.params['value'])\n", "\n"]}, {"term": "var", "brackets": false, "dialect": "sympy", "outputs": [], "source": ["from env.equation.data.terms.output.sympy.patterns.base import Base\n", "from env.equation.data.terms.output.sympy.patterns.base import Params\n", "from env.equation.data.terms.common.sympy.base import CommonSympy\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_sympy.var')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Var(Base, CommonSympy):\n", "\n", "    '''Generate cpp data for diff:\n", "    D[U(t-1.1), {x, 3}] -> sympy.diff(U(t-1.1, x), x, 3)'''\n", "\n", "    def __init__(self, net):\n", "\n", "        Base.__init__(self, net)\n", "        self.id = 'var'\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "        '''Used for dinamicaly fill local data'''\n", "        '''Orders and varList will be set here\n", "        from node's pattern (like {x, 2})\n", "        Return delay data.\n", "        '''\n", "        params = Params()\n", "            \n", "        reg_pattern = self.net.get_term_pattern(node)\n", "\n", "        # diff var (U):\n", "        var = reg_pattern.group('val')\n", "\n", "        # add args x, y to var:\n", "        var = self.add_args(var, reg_pattern)\n", "\n", "        # transform to sympy:\n", "        out = var\n", "\n", "        params['out'] = out\n", "        self.params['out'] = out\n", "\n", "        self.net.set_output_data(node, self.net.get_params_field_name(),\n", "                                 params)\n", "        \n", "    def print_out(self):\n", "        \n", "        '''For generate node out'''\n", "        \n", "        return(self.params['out'])\n", "\n", "\n"]}, {"term": "base", "brackets": false, "dialect": "sympy", "outputs": [], "source": ["\n", "import abc\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.base')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Params(dict):\n", "    '''\n", "    def __init__(self):\n", "        self.diffType = None  # 'pure'\n", "        self.diffMethod = None  # 'vertex'\n", "\n", "        # int: shift index for variable like\n", "        # like (U,V)-> (source[+0], source[+1])\n", "        self.unknownVarIndexes = []\n", "\n", "        # {x, 2}\n", "        self.indepVarList = []\n", "        self.indepVarOrders = {}\n", "        self.derivOrder = None\n", "\n", "        self.blockNumber = None\n", "        self.side = None\n", "    '''\n", "\n", "    def has_param(self, key, source):\n", "        try:\n", "            self[key]\n", "        except KeyError:\n", "            raise(KeyError('for term %s dont have %s param' % (source, key)))\n", "            \n", "\n", "class Base():\n", "    metaclass = abc.ABCMeta\n", "\n", "    '''Common methods for all cpp terms'''\n", "\n", "    def __init__(self, net):\n", "\n", "        self.net = net\n", "        self.params = Params()\n", "\n", "    def __call__(self, node):\n", "\n", "        '''Extract data from node lex pattern add it\n", "        to node.cpp.global_data and generate out to it\n", "        node.output.cpp.out'''\n", "\n", "        self.get_node_data(node)\n", "        \n", "        # transform to cpp:\n", "        self.net.set_output_out(node, self.print_out())\n", "\n", "    @abc.abstractmethod\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "\n", "        raise(BaseException(('get_node_data method of BaseTerm class'\n", "                             + ' must be implemented')))\n", "    \n", "    @abc.abstractmethod\n", "    def set_node_data(self, **kwargs):\n", "\n", "        '''For setting data before replacment'''\n", "\n", "        raise(BaseException(('set_node_data method of BaseTerm class'\n", "                             + ' must be implemented')))\n", "\n", "    @abc.abstractmethod\n", "    def print_out(self):\n", "\n", "        '''For generate node out'''\n", "\n", "        raise(BaseException(('print_out method of BaseTerm class'\n", "                             + ' must be implemented')))\n", "\n", "    def set_dim(self, **kwargs):\n", "        try:\n", "            dim = kwargs['dim']\n", "            self.params['dim'] = dim\n", "        except KeyError:\n", "            logger.info(\"kwargs['dim'] fail\")\n", "\n", "    def print_dbg(self, *args):\n", "        if self.dbg:\n", "            for arg in args:\n", "                print(self.dbgInx*' '+str(arg))\n", "            print('')\n", "\n"]}, {"term": "func", "brackets": true, "dialect": "sympy", "outputs": [], "source": ["from env.equation.data.terms.output.sympy.patterns.base import Params\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.func')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Func():\n", "    \n", "    '''for f (left=f right=))'''\n", "    \n", "    def __init__(self, net):\n", "        self.net = net\n", "        self.gnet = self.net.net\n", "\n", "        self.params = Params()\n", "\n", "        # this meen left_term.name == 'f'\n", "        # right_node.name == ')'\n", "        self.id = 'l:f|r:)'\n", "\n", "    def __call__(self, node_br):\n", "        \n", "        '''Add cpp out to brackets'''\n", "\n", "        successors = self.gnet.get_successors(node_br)\n", "        \n", "        left_node = successors[0]\n", "        right_node = successors[-1]\n", "\n", "        args_node = successors[1]\n", "\n", "        # get node data:\n", "        self.get_node_data(left_node, right_node)\n", "        \n", "        # transform to cpp:\n", "        left_out, right_out = self.print_out()\n", "\n", "        self.gnet.set_output_out(left_node, left_out)\n", "        self.gnet.set_output_out(right_node, right_out)\n", "\n", "    def get_node_data(self, left_node, right_node):\n", "\n", "        '''Used for fill local data'''\n", "\n", "        params = Params()\n", "        \n", "        value = self.gnet.get_term_value(left_node)\n", "        params['value'] = value\n", "        self.params['value'] = value\n", "        self.gnet.set_output_data(left_node, self.gnet.get_params_field_name(),\n", "                                  params)\n", "\n", "    def print_out(self):\n", "        \n", "        func = self.params['value']\n", "        # transform to sympy:\n", "        self.params['out'] = \"sympy.%s\" % (func)\n", "\n", "        right = \")\"\n", "        return(self.params['out'], right)\n", "\n"]}, {"term": "brackets_main", "brackets": true, "dialect": "sympy", "outputs": [], "source": ["from translator.replacer.replacer_brackets import GenBrackets\n", "\n", "from env.equation.data.terms.output.sympy.patterns.brackets.func import Func\n", "from env.equation.data.terms.output.sympy.patterns.brackets.idx import Idx\n", "\n", "import logging\n", "\n", "\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_sympy.brackets_main')\n", "\n", "# if using directly uncoment that:\n", "\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('cpp_net')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "terms_br_gens = [Func, Idx]\n", "\n", "\n", "class Out():\n", "    pass\n", "\n", "\n", "class BracketsNet(GenBrackets):\n", "    \n", "    '''Class for all brackets terms.\n", "    Terms for brackets replacement will be\n", "    in self[]'''\n", "\n", "    def get_terms_gen_cls(self):\n", "        return(terms_br_gens)\n", "\n"]}, {"term": "idx", "brackets": true, "dialect": "sympy", "outputs": [], "source": ["from env.equation.data.terms.output.sympy.patterns.base import Params\n", "\n", "import logging\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.func')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Idx():\n", "    \n", "    '''for f (left=f right=))'''\n", "    \n", "    def __init__(self, net):\n", "        self.net = net\n", "        self.gnet = self.net.net\n", "\n", "        self.params = Params()\n", "\n", "        # this meen left_term.name == 'i'\n", "        # right_node.name == ')'\n", "        self.id = 'l:i|r:]'\n", "\n", "    def __call__(self, node_br):\n", "        \n", "        '''Add cpp out to brackets'''\n", "\n", "        successors = self.gnet.get_successors(node_br)\n", "        \n", "        left_node = successors[0]\n", "        right_node = successors[-1]\n", "\n", "        args_node = successors[1]\n", "        \n", "        # get node data:\n", "        self.get_node_data(left_node, right_node)\n", "        \n", "        # transform to cpp:\n", "        left_out, right_out = self.print_out()\n", "\n", "        self.gnet.set_output_out(left_node, left_out)\n", "        self.gnet.set_output_out(right_node, right_out)\n", "\n", "    def get_node_data(self, left_node, right_node):\n", "\n", "        '''Used for fill local data'''\n", "\n", "        params = Params()\n", "        \n", "        # FOR left_node (a[):\n", "        if 'variable' in left_node.args:\n", "            # for func like f, g, h value must exist\n", "            # substituted with subs:\n", "            value = str(left_node.args['variable']['value'])+\"[\"\n", "        else:\n", "            # for func like sin, cos, exp:\n", "            # func = left_node.name.lex[0][:-1]\n", "            value = self.gnet.get_term_value(left_node)[:-1]\n", "        # END FOR\n", "\n", "        params['value'] = value\n", "        self.params['value'] = value\n", "        self.gnet.set_output_data(left_node, self.gnet.get_params_field_name(),\n", "                                  params)\n", "\n", "    def print_out(self):\n", "        \n", "        func = self.params['value']\n", "        # transform to sympy:\n", "        self.params['out'] = \"%s\" % (func)\n", "\n", "        right = \"]\"\n", "        return(self.params['out'], right)\n", "\n"]}, {"term": "source", "brackets": false, "dialect": "cpp", "outputs": [], "source": ["from env.equation.data.terms.output.cpp.patterns.base import Base\n", "\n", "import logging\n", "\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.source')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Source(Base):\n", "    \n", "    '''1.1\n", "    '''\n", "    \n", "    def __init__(self, net):\n", "        Base.__init__(self, net)\n", "        self.id = 'source'\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "        \n", "        # get found re pattern:\n", "        self.data = self.net.get_term_pattern(node)\n", "        \n", "        # get found string:\n", "        self.value = self.net.get_term_value(node)\n", "        # self.value = node.name.lex[0]\n", "\n", "    def print_out(self):\n", "    \n", "        '''For generate node out'''\n", "\n", "        return(self.value)\n", "\n", "\n"]}, {"term": "diff_2vv1", "brackets": false, "dialect": "cpp", "outputs": [], "source": ["from env.equation.data.terms.output.cpp.patterns.base import Base\n", "\n", "import logging\n", "\n", "# if using from tester.py uncoment that:\n", "# create logger that child of tests.tester loger\n", "logger = logging.getLogger('replacer_cpp.diff_2vv1')\n", "\n", "# if using directly uncoment that:\n", "'''\n", "# create logger\n", "log_level = logging.INFO  # logging.DEBUG\n", "logging.basicConfig(level=log_level)\n", "logger = logging.getLogger('equation')\n", "logger.setLevel(level=log_level)\n", "'''\n", "\n", "\n", "class Diff_2vv1(Base):\n", "    \n", "    '''1.3\n", "    '''\n", "    \n", "    def __init__(self, net):\n", "        Base.__init__(self, net)\n", "        self.id = 'diff_2vv1'\n", "\n", "    def get_node_data(self, node):\n", "\n", "        '''For getting data from node during replacment'''\n", "        '''Some data will be used by generator, some added to\n", "        node directly'''\n", "        \n", "        # get found re pattern:\n", "        re_pattern = self.net.get_term_pattern(node)\n", "        \n", "        # extract pattern data:\n", "        N = re_pattern.group(\"number\")\n", "        self.set_var_index(node)\n", "        \n", "        # extract data taken with set_ methods:\n", "        dim = self.params[\"dim\"]\n", "        blockNumber = self.params[\"blockNumber\"]\n", "        var_idx = self.params[\"unknownVarIndex\"]\n", "        diffMethod = self.params[\"diffMethod\"]\n", "        \n", "        # FOR delays:\n", "        delay_data = self.set_delay(node)\n", "\n", "        # add delays data for postproc:\n", "        if delay_data is not None:\n", "            # node.output.cpp.global_data = data\n", "            self.net.set_output_data(node, 'delay_data', delay_data)\n", "        # END FOR\n", "\n", "        if diffMethod == \"common\":\n", "        \n", "          bn = blockNumber\n", "          vi = var_idx\n", "        \n", "          value = \"(source[delay][idx + 2 * Block%dStrideX * Block%dCELLSIZE + %d]\" %(bn, bn, vi)\n", "          value += \"*source[delay][idx + 1 * Block%dStrideX * Block%dCELLSIZE + %d]\" %(bn, bn, vi)\n", "          value += \"-source[delay][idx - 1 * Block%dStrideX * Block%dCELLSIZE + %d]\" %(bn, bn, vi)\n", "          value += \"*source[delay][idx - 2 * Block%dStrideX * Block%dCELLSIZE + %d])\" %(bn, bn, vi)\n", "          value = str(int(N)/3) + \"*\"+value\n", "        else:\n", "          value = \"0\"\n", "          \n", "        # get found string:\n", "        self.value = value\n", "        # self.value = self.net.get_term_value(node)\n", "        # self.value = node.name.lex[0]\n", "\n", "    def print_out(self):\n", "    \n", "        '''For generate node out'''\n", "\n", "        return(self.value)\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n"]}]}